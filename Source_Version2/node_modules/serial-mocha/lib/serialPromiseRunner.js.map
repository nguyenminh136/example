{"version":3,"sources":["lib/serialPromiseRunner.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;AACb,IAAI,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC;IAC/B,YAAY,CAAC;AACf,MAAM,CAAC,OAAO,GAAG,YAAY,GAAG,UAAU,KAAK,EAAE;AAC/C,MAAI,EAAE,IAAI,YAAY,YAAY,CAAA,AAAC,EAAE;AACnC,WAAO,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;GAChC;AACD,MAAI,MAAM,GAAG,EAAE,CAAC;AAChB,MAAI,KAAK,EAAE;AACT,UAAM,GAAG,KAAK,CAAC;GAChB;AACD,MAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAClB,MAAI,CAAC,OAAO,GAAG,UAAU,IAAI,EAAE;AAC7B,UAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;GACnB,CAAA;AACD,MAAI,CAAC,QAAQ,GAAG,YAAY;AAC1B,WAAO,MAAM,CAAC;GACf,CAAA;CACF,CAAA;;;;;;;;;;;;;;;;;AAiBD,YAAY,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAU,MAAM,EAAE;AAClD,MAAI,IAAI,GAAG,IAAI,CAAC;AAChB,MAAG,CAAE,MAAM,EAAC;AACV,UAAM,GAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;GACxB;AACD,SAAO,IAAI,OAAO,CAAC,UAAU,OAAO,EAAE,MAAM,EAAE;AAC5C,cAAU,GAAG,CAAC,MAAM,EAAE;;;;;;AACpB,6BAAiB,MAAM,8HAAE;cAAhB,IAAI;;AACX,cAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC7B,cAAI,GAAG,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;AAClD,cAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAC,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,EAAC,CAAC;SACzD;;;;;;;;;;;;;;;KACF;AACD,WAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CACpC,IAAI,CAAC,UAAU,OAAO,EAAE;AACvB,aAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KACvB,CAAC,SACI,CAAC,UAAU,GAAG,EAAE;AACpB,YAAM,CAAC,GAAG,CAAC,CAAC;KACb,CAAC,CAAA;GACL,CAAC,CAAA;CACH,CAAA","file":"lib/serialPromiseRunner.js","sourcesContent":["/**\n * @module serialPromiseRunner\n *This module runs promises serially.\n * Multiple instances can be instantiated\n * It has two modes: run all tasks and stop on error\n **/\n'use strict';\nvar Promise = require(\"bluebird\"),\n  serialRunner;\nmodule.exports = serialRunner = function (tasks) {\n  if (!(this instanceof serialRunner)) {\n    return new serialRunner(tasks);\n  }\n  var _tasks = [];\n  if (tasks) {\n    _tasks = tasks;\n  }\n  this.results = {};\n  this.addTask = function (task) {\n    _tasks.push(task);\n  }\n  this.getTasks = function () {\n    return _tasks;\n  }\n}\n/**\n * Runs all tasks will stop on error.\n * A task is represented by a hash:\n * {name: The namespace upon which to hang the results,\n *  funct: a function which returns a promise (actual function not a string\n *  args: an array of arguments to be passed to the function\n *  Note that when the function is run it will include results as the last argument which contains a hash of\n *  the results run prior to its being called\n *  the results argument is a hash. Each namespace is an element of the hash e.g.\n *  results = {\n *    namespace1:{success:true, results:xxx},\n *    namespace2:{success:false, error:yyy}\n *    }\n *\n * @returns {bluebird}\n */\nserialRunner.prototype.runTasks = function (aTasks) {\n  var self = this;\n  if(! aTasks){\n    aTasks=self.getTasks();\n  }\n  return new Promise(function (resolve, reject) {\n    function *gen(aTasks) {\n      for (let task of aTasks) {\n        task.args.push(self.results);\n        let res = yield task.funct.apply(null, task.args);\n        self.results[task.name] = {success: true, results: res};\n      }\n    }\n    Promise.coroutine(gen)(self.getTasks())\n      .then(function (results) {\n        resolve(self.results);\n      })\n      .catch(function (err) {\n        reject(err);\n      })\n  })\n}"],"sourceRoot":"/source/"}